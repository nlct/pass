# Server PASS Documentation

This is the documentation for Server PASS.

## Installation

 - [Server Pass Setup](setupinit.md)
 - [Setting Up the Frontend](setupfrontend.md)
 - [Building the PASS Docker Image](buildingimage.md)
 - [Setting Up the Backend](setupbackend.md)
 - [Updates](updates.md)

## How Server Pass Works

The frontend is a website where students create an account, log in
and upload their project files. The upload page is a web equivalent
to Pass GUI: select the course, select the assignment, identify
members for group projects, select all project source files, and tick
the agreement checkbox. However, instead of then running PASS
directly, the site saves all the files in a sub-directory of
`/scratch/uploads`, adds the job details to the message queue
(RabbitMQ), and adds the job information to the website's database.

The student is then redirected to the [view uploads](list-uploads.md) page. They can
either hang around looking at this page while it periodically
reloads itself until the job is marked as completed in the database
or they can logout and do something else. If there's a long queue
(which can happen if everyone uses the site at the last minute), the
view uploads page will list their job's place in the queue.

The backend consists of a script called `passconsumer.php` that runs
in the background. It repeatedly queries the FIFO (first-in
first-out) message queue for jobs and, if the queue is non-empty,
pops off the first message.

The upload directories all have the naming scheme
_YYYY_`-`_MM_`-`_DD_`T`_hhmmssSSSTz_`_`_token_ where _YYYY_ is the
four digit year, _MM_ is the two digit month, _DD_ is the two digit
day of month, _hh_ is the two digit hour, _mm_ is the two digit
minutes, _ss_ is the two digit seconds, _SSS_ is the three digit
milliseconds and _Tz_ is the signed (`+` or `-`) four digit time
zone (for example, `+0100` for BST). The [token](#tokens) is a
sequence of 10 lowercase hexit (`0`–`9`, `a`–`f`) characters and is
randomly generated by the frontend.

Each message in the queue is JSON-encoded containing the numeric job ID,
the upload timestamp, and the token.

The frontend not only saves all project files in the upload
directory, but also creates a `.txt` file in the format required by
[Pass CLI's `--from-file` switch](../passcli.md). The backend reads
this file and picks up the usernames and the output PDF filename.

The backend then starts a Pass Docker container (based on Debian) with
the server's `/scratch/texlive` directory mounted read-only onto the container's
`/usr/local/texlive` path, the submission's upload directory mounted read-only onto
the container's `/usr/src/app/files` path, and runs `pass-cli-server`:
<pre>
pass-cli-server --job-id <em>JobID</em> --encoding UTF-8 --transcript pass.log --directory files --from-file files/<em>settings-file</em>
</pre>
where _JobID_ is the job ID obtained from the message queue, and
_settings-file_ is the `.txt` file the frontend created.
(UTF-8 is the encoding for the transcript file and settings file,
and matches the default encoding set in the Docker image. It
may not be the encoding of the student's uploaded source code, which
hopefully they correctly identified, but it's best to encourage them
to use UTF-8 where possible.)

If the container process finishes successfully, a new directory is created
inside `/scratch/passdocker/completed/` and the backend will copy
the PDF and `pass.log` files from the container into that
new directory. The backend updates the job's status to "completed" in
the database and sends an email to each supplied username to inform
them that the process has finished. If the PDF was successfully
created, the student will then be able to download it from the
[view uploads page](list-uploads.md). The container is deleted.

The backend is run in the background using `nohup` (no hang up) so any error messages
written by the backend to STDERR will be written to `nohup.out`.
Other messages (information about each submission that's processed)
is written to `passdocker.log`. The frontend admin area has
[a page](admin-processlogs.md) that checks these files for errors and other messages.

## Security

PASS was designed to compile and run command line applications that
students need to create for programming assignments. This means compiling and
running unchecked code which may contain potentially dangerous code,
either by an accidental bug written by an inexperienced student or
by malicious intent. The use of a Docker container helps to limit
the effects of bad code but it's essential that the server is setup
by an IT expert. I'm not a security professional. The installation
guidelines here should be considered a minimal set that will need to
be checked and tightened by a security expert.

The output PDF not only has source code listings but also
has a zip attachment containing all the source code files.
This zip file is created using the `java.util.zip` package rather
than using an installed zip application.

Normally, PASS doesn't allow binary files, except for PDF and Word
documents for accompanying reports. Be aware that these PDF or Word
attachments could potentially contain malware so ensure that you
have antivirus software and other precautions.

You can instruct PASS to allow other binary files that will be
included in the zip attachment or attached as a result file. This
feature is mainly intended to allow students to include image files.
PASS performs a file probe to determine whether or not the
supplied binary file matches the specified MIME type, but be aware
that this probe can fail to correctly identify the content.

### Passwords

The frontend requires users to create a password-protected account
in order to upload a project. The minimum password length is 8
characters. Any characters are permitted but common and easily
guessable passwords are forbidden. Passwords are stored as a salted
hash. There's no provision for integration with any single sign on
(SSO) system. (The server is expected to be isolated, except for
access to PASS's resource and assignment files.)

### Multifactor Authentication

The frontend account can be further protected by enabling two-factor
authentication (2FA). This uses a time-based one-time password
(TOTP) authentication method that's compatible with most
authenticator apps. The secret key is stored as an encrypted value.

The site also allows the creation of single use recovery codes. A
new set of recovery codes can be created if they are all used up or
if a user suspects that they have been compromised. Any existing
codes will be deleted if a new set is created.

If 2FA is enabled, there is an option to trust the current device
for 30 days. This means that only the password will be required
to log in during that period, provided that the trust token stored in the
cookie remains valid. If a user suspects that the trust token
may have been discovered by a third party, they can cancel
the token from their account page.  The cookie used to store the
trust token has the `httponly` attribute set to `true` and the
`samesite` attribute set to `Strict`.

Any failed 2FA attempt (either TOTP or recovery code) will trigger
an email to the user notifying them. If a user receives an email
when it wasn't them attempting to log in, they should change their
password.

### Tokens

The web scripts use randomly generate tokens for a variety of
purposes. To ensure an ASCII-safe string, the `create_token($num_bytes)`
function in `config.php` is used to create a randomly generated token that
has the given number of bytes that is then converted into a hexadecimal string where
each byte is represented by two hexadecimal digits. So, for example,
a 5 byte random token will be converted into a 10 character string consisting of
a sequence of characters in the set `a`–`f`, `0`–`9` (lowercase hexadecimal
digits or hexits).

Each upload directory has a name formed by the upload timestamp
(which includes milliseconds) and a random 10 character token. The
chances of two students coincidentally uploading their projects at
the same millisecond is quite slim, but the random token reduces the
probability of a clash even further. The timestamp and hexadecimal
token are stored separately in the database but can be combined to
determine the directory name. The token in this case isn't so much
for security as for uniqueness.

The other types of tokens are used for verification purposes and are
formed from two randomly-generated selector and verifier tokens:

  - tokens with an expiry date;
  - single-use tokens without an expiry date.

In both cases, the selector is simply stored unencrypted as a binary
object in the database.

The tokens with an expiry date are: account verification tokens,
password reset tokens, and trust tokens. The selector and verifier
are both 16 bytes long (so the combined ASCII token is 64 characters
long). The verifier itself isn't stored in the database.  Instead a
keyed-hash message authentication code (HMAC) using the SHA256
algorithm is stored, where the input message data is the JSON
encoded array consisting of the actual verifier, the user ID and
expiry time. (See the `getHashedVerified(string,int,DateTime)`
function in the `inc/config.php` file.) The selector is stored as a 16
byte binary object and the keyed-hash value is stored as a 32 byte
binary object. This method of splitting the token
[helps to mitigate against time-based attacks](https://paragonie.com/blog/2017/02/split-tokens-token-based-authentication-protocols-without-side-channels).

Single-use tokens without an expiry date are used for account
recovery codes. The selector and verifier are both 6 characters
long. In this case, the keyed hashed method isn't used.  Instead,
the verifier is encrypted using the sodium library (see the
`encryptRecoveryCode($datastring)` function in the `inc/config.php`
file) and the encrypted value is stored in the database as a
128-byte binary object. The selector is stored unencrypted as a 12
byte binary object.

## Privacy

PASS was designed for a university that uses the Blackboard
learning management system. Each student has an alphanumeric
username that doesn't contain personally identifiable information,
and their email address can be formed from the username and the
university's domain name. A more memorable email alias is also
available, but that information isn't stored by the frontend.

If you don't use Blackboard, you'll need to change the textual
labels to replace "Blackboard ID" with something more applicable,
but the assumption is that the student's username is their email
username and either their username or their student registration
number is needed to log their assignment mark. If the username
shouldn't appear on the PDF, edit the `getAuthor(Student)` function
in [`inc/AssignmentProcessConfig.php`](https://github.com/nlct/pass/blob/main/pass-lib/java/AssignmentProcessConfig.java-template) as applicable.

When a student creates an account on the frontend, the username they
supply must match their email username. There is no provision for a
user to specify an alternative email address. This ensures that all
users have a university account. Without an email address that can
be formed from their username and the university's domain, they
won't be able to receive the account verification email.

The following details are stored in the `users` database table:

  - the username;
  - the student registration number;
  - the password (salted hash);
  - the user role (student, staff or admin);
  - the user's account status (pending, verified or blocked);
  - the account creation data;
  - the TOTP secret key (encrypted);
  - the verification state of the secret key (true if verified);
  - whether or not the 2FA setting has been enabled.

The only identifiable information is the username and registration
number, which are needed to log into their account or for the
lecturer to log the assignment mark.

There is one required cookie, which is a session cookie needed
to determine whether or not a user has been authenticated.
This cookie simply contains the session ID.

There is one optional cookie, which has a lifespan of 30 days, and
is an opt-in trust setting to allow 2FA to be skipped.
This cookie stores the trust token.

## Website Documentation

🚧 

### General Web Pages

 - [List Uploads](list-uploads.md)

### Admin Pages

Users with "admin" status can access the Admin pages.

 - [Configuration](admin-config.md)
 - [Users](admin-users.md)
 - [Upload Directories](admin-uploaddir.md)
 - [Process Logs](admin-processlogs.md)
 - [Who's Online](admin-whosonline.md)
 - [Session Data](admin-sessiondata.md)
 - [Action Recorder](admin-recorder.md)
 - [Backend Maintenance](admin-maintenance.md)
 - [PHP Info](admin-info.md)

---

Up: [Documentation Home](../README.md)
